// 프로그램 목적: selection(선택정렬) 알고리즘
#include <stdio.h>

void Selection(int* num, int N, int input); // 함수선언

int main(void) // main함수 시작
{
	// 변수선언
	int i = 0; // 제어변수: 반복입력을 위한 for문 제어
	int j = 0; // 제어변수: 배열저장 모든 원소값의 출력을 위한 for문 제어
	int num[9]; // 배열선언: 자료를 입력받아 저장할 배열선언
	int N = sizeof(num) / sizeof(int); // 제어변수: 배열원소개수 계산
	int input = 0; // 입력변수: 오름차순 또는 내림차순 코드를 입력받음

	// 자료입력
	printf("선택정렬을 수행할 9개의 정수를 입력해주십시오.\n");
	for (i = 0; i < 9; i++) // 배열의 첫번째원소부터 마지막원소까지 입력받음
	{
		printf("\"%d번째\"원소 입력: ", i+1); // 헷갈리지 않도록 표시
		scanf_s("%d", num + i);
	}	

    // 선택정렬 전의 자료출력
	printf("\n선택정렬 전의 자료: ");
	for (j = 0; j < N; j++)
		printf("%4d", *(num + j)); // *(num + j)의 다른 표현: num[j]
	printf("\n\n");

	while (1) // 무한루프 생성
	{    
		// 자료입력
		printf("오름차순정렬을 원하시면 \'1\'을 내림차순정렬을 원하시면 \'2\'를 입력해주십시오: ");
		scanf_s("%d", &input);
		if (input == 1 || input == 2)
			break;
		printf("잘못입력하셨습니다. 다시 한 번 입력해주십시오.\n\n\a\a\a\a");
	} 
	
	// 자료처리
	Selection(num, N, input); // 함수호출
	
	// 선택정렬 후의 자료출력
	printf("선택정렬 후의 자료: ");
	for (j = 0; j < N; j++)
		printf("%4d", *(num + j));
	printf("\n\n");

	return 0; // 실행종료
} // main함수 종료

void Selection(int* num, int N, int input) // 함수정의: 선택정렬의 핵심정의 부분 (1번 참고)
{
	// 변수선언
	int i = 0, j = 0; // 제어변수: for문 제어
	int temp = 0; // 임시저장변수: swap의 결과를 임시저장

	// 자료처리
	for (i = 0; i < N - 1; i++) // 배열의 경우 시작이 '0'이므로 이렇게 쓴 것임 => i가 '1'인 경우도 생각해 볼 것!
	{ // 외부 for문 시작
		for (j = i; j < N; j++)
		{ // 내부 for문 시작
			switch (input)
			{ // switch문 시작
			case 1: // 오름차순 정렬 
				if (num[i] > num[j])
				{ // case1의 if문 시작
					temp = num[i];
					num[i] = num[j];
					num[j] = temp;
				} // case1의 if문 종료
				break;
			case 2: // 내림차순 정렬
				if (num[i] < num[j])
				{ // case2의 if문 시작
					temp = num[i];
					num[i] = num[j];
					num[j] = temp;
				} // case2의 if문 종료
			} // switch문 종료
		} // 내부 for문 종료
	} // 외부 for문 종료
}

// 1) 선택정렬의 로직: 각 자리에 크기순대로 원소값 할당, 한 번 할당되면 그 자리 제외 =>  'N'개 자료는 'N-1'번 루프수행
// 오름차순 선택정렬: 작은 값일수록 앞에 위치
// 원소의 개수가 5개라고 가정하는 경우, 루프의 변화추이 관찰
// 루프#1: (1,2)->(1,3)->(1,4)->(1,5) // 첫번째와 2~5번째 원소를 비교 후 가장 작은 값을 첫번째 원소에 저장 => 목적: 가장 작은 값을 첫번째 원소에 저장
// 루프#2: (2,3)->(2,4)->(2,5) // 두번째와 3~5번째 원소를 비교 후 가장 작은 값(전체로는 두번째 작은 값)을 두번째 원소에 저장 => 목적: 두번째 작은 값을 두번째 원소에 저장
// 루프#3: (3,4)->(3,5) // 세번째와 4~5번째 원소를 비교 후 가장 작은 값(전체로는 세번째 작은 값)을 세번째 원소에 저장 => 목적: 세번째 작은 값을 세번째 원소에 저장
// 루프#4: (4,5) // 네번째와 5번째 원소를 비교 후 작은 값을 네번째 원소에 저장, 이렇게 하면 다섯번째 원소의 값은 자동확정 => 목적: 네번째 작은 값을 네번째 원소에 저장
// (단, 각 숫자는 각 자리의 원소를 의미 => 예: 1의 경우 첫번째 원소 저장값)
// 
// 2) 선택정렬의 핵심문장설명 (오름차순 기준)
// i는 몇 번째 원소인지 표시, N은 원소의 개수를 표시(즉, 마지막원소가 몇 번째인지 표시) 
// for(i=0; i<N-1; i++) // 외부 for문: 첫번째원소에서 마지막원소까지 변화(비교기준) => 목적: 각 원소자리값을 확정하며 변화
// {
//     for(j=i; j<N; j++) // 내부 for문: i보다 한자리 큰 원소부터 마지막원소까지 변화하며 비교(비교대상) => 목적: i의 비교대상
//     if(num[i] > num[j]) // 조건문: i번째 저장된 값이 j번째 저장된 값보다 크면, 더 작은 값을 앞으로(즉, i로) 보냄 => 주의) j는 항상 i보다 큼
//     {   // Swap로직: num[i]의 저장값과 num[j]의 저장값을 서로 swap하는 로직
//         tmp = num[i]; // tmp에 num[i]의 값을 임시저장
//         num[i] = num[j]; // num[i]에 num[j]의 값을 저장 (num[i]의 기존저장값은 소실)
//         num[j] = tmp; // num[j]에 tmp에 저장된 num[i]의 값을 저장 (num[j]의 기존저장값은 소실)
//     }   // Swap의 결과: num[i]에는 num[j]의 기존값이 num[j]에는 num[i]의 기존값이 저장됨
// }
//
// 3) Swap 알고리즘
// Swap을 하기 위해서는 반드시 3개 변수가 필요하다 => 그 이유는 바로 아래 설명
// 변수 2개로 swap을 수행하는 예를 들어보자 => int a = 0, b = 1;
// a = b; // 1단계: a에는 원래 '0'이 저장되어 있었는데 대입연산을 하면서 b의 값 '1'로 갱신되고 이에 따라 기존 저장값 '0'은 소멸된다.
// b = a; // 2단계: b에 1단계에서 처리된 a의 값 '1'을 저장하게 되므로 b는 기존저장값과 동일한 '1'을 저장하게된다.
// 결론적으로 a와 b 모두 '1'이 저장되게 되어 논리적 오류가 발생하게 된다.
// 이를 방지하기 위해서 3개의 변수를 아래와 같이 사용할 수 있다.
// int a = 0, b = 1, tmp = 0;
// tmp = a; // 1단계: tmp라는 임시저장변수에 a의 값 '0'을 저장한다.
// a = b; // 2단계: a의 변수공간에 b의 값 '1'을 저장한다. (a의 기존저장값 '0'은 소실됨)
// b = tmp; // 3단계: b의 변수공간에 tmp에 저장된 기존 a의 값 '0'을 저장한다. (b의 기존저장값 '1'은 소실됨)
// 결론적으로 a는 기존 b의 저장값 '1'을 저장하게되고 b는 기존 a의 저장값 '0'을 저장하게 되어 a와 b의 저장값이 서로 바뀌어서 저장된 결과를 확일할 수 있다.