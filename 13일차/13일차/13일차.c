// 프로그램 목적: 1차원 배열의 주소값과 포인터변수의 저장값 그리고 주소값의 관계에 대한 탐구
#include <stdio.h>

int main(void) // main함수 시작
{
	// 변수선언
	int a[] = { 1,2,3,4,5 }; // 배열선언
	int* p = a; // 포인터변수선언: 배열 a를 간접참조
	int i = 0; // 제어변수: for문 제어

	// 자료처리 및 출력: 배열의 주소값 출력
	printf("배열의 주소를 4가지 방법을 이용하여 출력하겠습니다.\n\n");

	printf("1) 배열명 a를 이용한 배열주소 출력\n"); // 방법1
	for (i = 0; i < 5; i++)
		printf("a[%d]의 주소: %p\n", i, a + i); // 중요) 배열명 'a'는 그 자체로 "시작주소"를 의미하는 "포인터상수"

	printf("\n2) 각 배열원소의 주소를 이용한 배열주소 출력\n"); // 방법2
	for (i = 0; i < 5; i++)
		printf("&a[%d]의 값: %p <=> a[%d]의 주소\n", i, &a[i], i); // &a[i]는 각 배열원소의 주소를 나타냄

	printf("\n3) 포인터변수 p를 이용한 배열주소 출력 (포인터변수 주소값 유지)\n"); // 방법3: 포인터변수 주소값 유지 (방법 4와 비교)
	for (i = 0; i < 5; i++)
		printf("포인터변수 p의 저장값: %p <=> a[%d]의 주소\n", p + i, i); 
	// 포인터변수 p에는 "&a[0]", 즉 배열의 시작주소가 저장
    // p+i는 배열의 시작주소에서 간접참조변수의 자료형크기(예.int=4바이트)*i만큼 주소증가

	printf("\n4) 포인터변수 p를 이용한 배열주소 출력 (포인터변수 주소값 갱신)\n"); // 방법4: 포인터변수 주소값 갱신
	for (i = 0; i < 5; i++) // 주의) p++; <=> (p = p; -> p = p + 1;)
		printf("포인터변수 p의 저장값: %p <=> a[%d]의 주소\n", p++, i); 
	// 주의) p++; <=> "p==&a[0]"이므로 "&a[0]->&a[1]->...->&a[4]"인 변화추이를 형성
	// 루프를 돌 때마다 저장값이 아닌 주소값이 피참조변수 자료형단위만큼 증가

	printf("\n주의) 포인터변수 p의 배열원소주소를 이용하여 배열주소 출력 => &a[i]와는 별개\n"); // 방법4
	for (i = 0; i < 5; i++)
		printf("&p[%d]의 값: %p\n", i, &p[i]); // 주의) &p[i]는 포인터변수 p의 각 원소의 주소를 나타냄 => &a[i]와는 별개
	printf("\n");

	return 0; // 실행종료
} // main함수 종료
// 중요) 결국 배열은 포인터상수로 포인터의 특수한 경우이다. => 따라서 배열도 포인터상수처럼 '*'를 붙여 값 출력이 가능하며 포인터도 배열처럼 원소를 'ptr[0]'과 같이 나타낼 수 있다. 
// 배열은 "상수"이므로 저장값을 바꿀 수 없지만 포인터변수는 "변수"이므로 저장값을 바꿀 수 있다. 
// 일반변수 : 일반상수 = 포인터변수 : 배열(포인터상수) => 일반변수/상수는 저장대상이 "값(Value)"이고 포인터변수/상수는 저장대상이 "주소(Reference)"이다.