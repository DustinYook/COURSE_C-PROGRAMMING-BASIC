// 프로그램 목적: 1차원 배열의 저장값과 포인터변수가 참조하는 변수의 저장값(*ptr)의 관계 탐구
#include <stdio.h>

int main(void) // main함수 시작
{
	// 변수선언
	int a[] = { 1,2,3,4,5,6,7,8,9,10}; // 배열선언
	int* p = a; // 포인터변수선언: 배열 a를 간접참조
	int i = 0; // 제어변수: for문 제어

	// 자료처리 및 출력: 배열의 저장값 출력
	printf("배열의 저장값을 4가지 방법을 이용하여 출력하겠습니다.\n\n");

	printf("1) 배열 a의 각 원소저장값을 이용한 배열저장값 출력\n"); // 방법1
	for (i = 0; i < 5; i++)
		printf("a[%d]의 저장값: %d <=> (p+%d)\n", i, a[i], i); // 중요) a[i]: 배열 각 원소에 저장된 값 <-> 구분) &a[i]: 배열 각 원소의 주소
	
	printf("\n2) 포인터변수 p의 각 원소저장값을 이용한 배열저장값 출력\n"); // 방법2 
	for (i = 0; i < 5; i++)
		printf("포인터변수 p[%d]의 저장값: %d\n", i, p[i]); 

	printf("\n3) 포인터변수 p가 간접참조하는 배열의 저장값을 이용한 배열저장값 출력 (포인터변수 저장값 유지)\n"); // 방법3: 포인터변수 저장값 유지 (방법 4와 비교)
	for (i = 0; i < 5; i++)
		printf("*(p+%d)의 저장값: %d\n", i, *(p + i));

	printf("\n4) 포인터변수 p가 간접참조하는 배열의 저장값을 이용한 배열저장값 출력 (포인터변수 저장값 갱신)\n"); // 방법4: 포인터변수 저장값 갱신
	for (i = 0; i < 5; i++)
		printf("*p++의 저장값: %d\n", *p++); 
		// 주의) for문 루프가 i가 '0'부터 '4'일 때까지 5번 반복하므로 p++(p = p; -> p = p + 1;)도 5번 수행 
		// => "p = p + 1;"과 같이 대입연산을 수행하므로 포인터변수에 저장된 주소값이 갱신된다.

	printf("\n참고) 포인터변수 저장값을 갱신한 후의 포인터변수의 간접참조값 변화 관찰\n"); // 포인터변수의 저장값이 &a[0]에서 &a[6]으로 갱신됨
	for (i = 0; i < 5; i++)
		printf("*(p+%d)의 저장값: %d\n", i, *(p+i)); // 따라서 출력값은 "a[0]->...->a[5]"에서 "a[6]->...->a[10]"으로 변경 
	printf("\n");
		
	return 0; // 실행종료
} // main함수 종료

// 주의1) "(*p)++": 저장값 증가 =>포인터변수 p가 간접참조하는 배열의 저장값을 해당 배열에 저장 후(*p = *p;), 그 저장값을 '1' 증가시켜 해당배열에 저장(*p = (*p) + 1;)
// 주의2) "*p++": 주소값 증가 => 포인터변수 p에 저장된 주소값을 p에 저장 후(p = p;), 그 주소값을 '1' 증가시켜 p에 다시 저장한 후(p = p + 1;), 해당주소에 저장된 값을 출력 (*(p+1))
// 주의3) 배열명은 포인터상수이므로 저장된 값을 갱신할 수 없다 
// => *(배열명+i)는 저장값을 갱신하지 않기 때문에 가능 (방법3 참고) 
// => *(배열명++)는 저장값을 갱신하기 때문에 불가능 (방법4 참고)
// 참고) 포인터변수는 변수이므로 저장된 값을 갱신할 수 있기 때문에 *(포인터변수명+i)와 *(포인터변수명++) 모두가능하다
// 참고) 배열명[0] = 포인터명[0] = *배열명 = *포인터명 (단, 포인터변수가 해당 배열을 간접참조할 때)
// *p++: p값 변함 vs *(p + i): p값 유지
// 주의) 전제: 'a'를 배열명이라하고 'i'(가변적)를 제어변수라 가정
// => 'a'는 "배열의 시작주소값", '&a'는 "배열의 시작주소값"(?)
// => 'a[i]'는 "배열의 각 원소 저장값", '&a[i]'는 "배열 각 원소의 시작주소값"
// => '*a'는 "배열의 시작주소에 저장된 값"
// *배열명 or *(&변수명) => 저장값