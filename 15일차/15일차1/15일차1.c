// 프로그램 목적: 버블정렬 알고리즘 (flag를 사용하는 경우)
#include <stdio.h>

int Bubble(int* num, int N, int order); // 함수선언: 버블정렬수행 => 주의) int* num는 저장값을 의미하는 것이 아니라 포인터변수를 선언하는 것임에 주의!
// 전달받을 때는 포인터변수, 선언에는 배열로 해야함
void Print(int* num, int N); // 함수선언: 출력수행 

int main(void) // main함수 시작
{
	// 변수선언
	int i = 0; // 제어변수: 반복입력을 위한 for문 제어
	int j = 0; // 제어변수: 배열저장 모든 원소값의 출력을 위한 for문 제어
	int num[9]; // 배열선언: 자료를 입력받아 저장할 배열선언
	int N = sizeof(num) / sizeof(int); // 제어변수: 배열원소개수 계산
	int order = 0; // 입력변수: 오름차순 또는 내림차순 코드를 입력받음

	// 자료입력
	printf("선택정렬을 수행할 9개의 정수를 입력해주십시오.\n");
	for (i = 0; i < 9; i++) // 배열의 첫번째원소부터 마지막원소까지 입력받음
	{
		printf("\"%d번째\"원소 입력: ", i + 1); // 헷갈리지 않도록 표시
		scanf_s("%d", num + i);
	}

	// 자료출력 1: 버블정렬을 수행하기 전의 자료 출력 
	printf("\n선택정렬 전의 자료: ");
	Print(num, N);

	while (1) // 무한루프 생성
	{
		// 자료입력
		printf("오름차순정렬을 원하시면 \'1\'을 내림차순정렬을 원하시면 \'2\'를 입력해주십시오: ");
		scanf_s("%d", &order);
		if (order == 1 || order == 2)
			break;
		printf("잘못입력하셨습니다. 다시 한 번 입력해주십시오.\n\n\a\a\a\a");
	}

	// 자료처리
	Bubble(num, N, order); // 함수호출

    // 자료출력 2: 버블정렬을 수행한 후의 자료 출력 
	printf("선택정렬 후의 자료: ");
	Print(num, N);

	return 0; // 실행종료
} // main함수 종료

void Print(int* num, int N) // 함수정의 1: 배열원소 출력
{
	int i = 0;
	for (i = 0; i < N; i++)
		printf("%4d", *num++); // *(num + i)의 다른 표현: num[i] (여기 num과 main의 num은 전혀 다른 변수 => 여기: 포인터변수, main: 배열명)
	printf("\n\n");
}

int Bubble(int* num, int N, int input) // 함수정의 2: 버블정렬 수행 (1번 참고)
{
	int i = 0, j = 0; // 제어변수
	int temp = 0; // 임시저장변수
	int flag = 0; // 자료배치형태 판단

	for (i = 0; i < N - 1; i++) // 외부 for문: 회전수 제어
	{
		flag = 0; // 중요) 루프 돌때마다 초기화: 모두 일렬로 정렬되어 있으면 종료 => 완벽히 정렬이 되어있으면 아래 if(flag==0)전의 문장까지 '0'의 값을 유지
		for (j = 0; j < N - i - 1; j++) // 내부 for문: 비교기준과 비교대상 제어
			switch (input)
			{
			case 1:
				if (num[j] > num[j + 1]) // swap문은 flag를 사용하지 않을 때와 동일
				{ // 참고) 블록을 빼려면 j와 j+1의 주소를 모두 전달해야 함
					temp = num[j];
					num[j] = num[j + 1];
					num[j + 1] = temp;
					flag = 1; // 중요) 정렬이 되었는지 다시 한 번 점검할 필요가 있음
				}
				break;

			case 2:
				if (num[j] < num[j + 1])
				{
					temp = num[j];
					num[j] = num[j + 1];
					num[j + 1] = temp;
					flag = 1; 
				}
			}
		if (flag == 0) // 완벽히 정렬이 되어 있으면 '0'의 값을 유지 => 이 경우 Bubble함수를 종료
			return 0; // 1) 모든 루프를 다 돌기 전에 정렬이 완료가 된 경우: main함수로 돌아가기
	}
	return 0; // 2) 모든 루프를 다 돈 경우: main함수로 돌아가기
}

// 1) flag의 의미: flag는 자료배치가 순차적(오름차순 또는 내림차순)으로 배치된 경우 '0'의 값을 유지
//                flag는 정렬이 필요한 경우 '0'의 값이 '1'로 갱신됨
// 전반적인 로직은 flag를 사용하지 않는 경우의 버블정렬과 동일하지만 자료구조에 따른 회전수 감축을 위해 flag를 사용하는 점만 다름
// flag의 효과: 자료배치구조에 따라서 회전수가 달라짐 => 예) 오름차순을 하는 경우 "1,2,...,9"의 자료와 "9,8,...,1"의 자료를 정렬하는데 필요한 회전수는 상이하다. (전자가 훨씬 적음)
//
// 2) flag를 사용한 버블정렬의 핵심문장설명 (오름차순 기준) 
// i는 회전수를 표시, j는 비교기준과 비교대상을 표시, N은 원소의 개수를 표시(마지막원소가 몇 번째인지 표시) 
// flag는 정렬의 필요여부를 표시하는 제어변수임 => '0'인 경우 "정렬완료"를 의미하고 '1'인 경우 "정렬필요"를 의미함
// for(i=0; i<N-1; i++) // 외부 for문: 몇 번째 회전을 수행했는지 표현
// {
//     flag = 0; 중요) 루프를 돌 때마다 초기화 됨 => 한 루프를 종료하면 반드시 flag를 '0'으로 초기화시키는 작업이 필요 (3번 참고)
//     for(j=0; j<N-i-1; j++) // 내부 for문: j는 비교기준, j+1은 비교대상을 표시 
//     if(num[j] > num[j+1]) // 조건문: j번째 저장된 원소값이 j+1에 저장된 원소값보다 크면 j번째 원소저장값을 j+1번째 원소저장값과 Swap 
//     { // 아래는 Swap
//         tmp = num[j]; // j번째 저장값을 임시저장변수인 tmp에 저장
//         num[j] = num[j+1]; // j+1번째 저장값을 j번째 원소위치에 저장 (num[j]의 기존값은 소멸)
//         num[j+1] = tmp; // j+1번째 원소위치에 j번째 저장값을 저장 (num[j+1]이 기존값은 소멸) 
//         flag = 1; // 
//     } // 내부 for문을 빠져나온 경우 => 1) flag=0인 경우: 더 이상의 정렬 불요  2) flag=1인 경우: 1회 정렬수행(추가 정렬이 필요할수도 있음) 
//     if (flag == 0) //  flag의 값이 '0'이면 더 이상의 정렬이 필요하지 않으므로 외부 for문을 빠져나오고 return문을 실행하여 사용자정의함수 실행을 종료 (1인 경우 다시 위로 돌아감) 
//         return 0; // 사용자정의함수에서 return은 "사용자정의함수 실행을 종료하고 main함수의 함수호출부로 돌아가라는 의미"
// }
// 
// 3) flag = 0;이 반드시 필요한 이유: flag = 0이라는 문장이 없으면 정렬을 한 후에도 계속 '1'의 값이 유지되어 모든 루프를 불필요하게 수행
// flag = 0를 통해 정렬이 되면 바로 빠져나갈 수 있게 해주도록 함
// 즉, 정리하면 각 루프가 정렬이 된 상태('0')의 초기값을 부여받고 정렬이 되어 있으면 Swap을 수행하지 않고 if(flag==0)에 의해 빠져나가고
// 정렬이 되어있지 않으면 Swap을 수행하고 flag의 값이 '1'로 갱신됨 => 외부 for문을 다시 한 번 반복하게 됨, 이를 통해 정렬이 되었는지 검사하는 효과를 창출