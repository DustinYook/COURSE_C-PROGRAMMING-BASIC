// 프로그램 목적: 버블정렬 알고리즘 (flag를 사용하지 않는 경우)
#include <stdio.h>

void Bubble(int* num, int N, int input); // 함수선언: 버블정렬수행 => 주의) int* num는 *num의 의미와는 전혀 다름! 
void Print(int* num, int N); // 함수선언: 출력수행

int main(void) // main함수 시작
{
	// 변수선언
	int i = 0; // 제어변수: 반복입력을 위한 for문 제어
	int j = 0; // 제어변수: 배열저장 모든 원소값의 출력을 위한 for문 제어
	int num[9]; // 배열선언: 자료를 입력받아 저장할 배열선언
	int N = sizeof(num) / sizeof(int); // 제어변수: 배열원소개수 계산
	int input = 0; // 입력변수: 오름차순 또는 내림차순 코드를 입력받음

	// 자료입력
	printf("버블정렬을 수행할 9개의 정수를 입력해주십시오.\n");
	for (i = 0; i < 9; i++) // 배열의 첫번째원소부터 마지막원소까지 입력받음
	{
		printf("\"%d번째\"원소 입력: ", i + 1); // 헷갈리지 않도록 표시
		scanf_s("%d", num + i);
	}

	// 자료출력 1: 버블정렬을 수행하기 전의 자료 출력 
	printf("\n버블정렬 전의 자료: ");
	Print(num, N);

	while (1) // 무한루프 생성
	{
		// 자료입력
		printf("오름차순정렬을 원하시면 \'1\'을 내림차순정렬을 원하시면 \'2\'를 입력해주십시오: ");
		scanf_s("%d", &input);
		if (input == 1 || input == 2)
			break;
		printf("잘못입력하셨습니다. 다시 한 번 입력해주십시오.\n\n\a\a\a\a");
	}

	// 자료처리
	Bubble(num, N, input); // 함수호출

	// 선택정렬 후의 자료출력
	printf("버블정렬 후의 자료: ");
	Print(num, N);

	return 0; // 실행종료
} // main함수 종료

void Print(int* num, int N) // 함수정의 1: 배열원소 출력
{
	int i = 0; // 제어변수: for문 제어 => 모든 배열 원소 출력
	for (i = 0; i < N; i++)
		printf("%4d", *num++); // 다른표현: num[i] 또는 *(num + i) 
	                           // => main함수의 num은 배열명, Print에서 num은 포인터변수 (서로 이름만 같을 뿐 별개)
	printf("\n\n");
}

void Bubble(int* num, int N, int input) // 함수정의 2: 버블정렬 수행 (1번 참고)
{ // 사용자정의함수 시작
	int i = 0; // 제어변수: 루프의 회전수 제어
	int j = 0; // 제어변수: 비교기준과 비교대상 제어
	int temp = 0; // 임시저장변수: Swap을 위한 임시저장공간

	for (i = 0; i < N - 1; i++)  // 외부 for문: 루프의 회전수 제어  
	{ // 외부 for문 시작
		for (j = 0; j < N - i - 1; j++)  // 내부 for문: 비교기준과 비교대상 제어 (2번 참고)
			switch (input)
			{ // switch문 시작
			case 1: // 오름차순 정렬
				if (num[j] > num[j + 1])
				{ // case1의 if문 시작
					temp = num[j];
					num[j] = num[j + 1];
					num[j + 1] = temp;
				} // case1의 if문 종료
				break;
			case 2: // 내림차순 정렬
				if (num[j] < num[j + 1])
				{ // case2의 if문 시작
					temp = num[j];
					num[j] = num[j + 1];
					num[j + 1] = temp;
				} // case2의 if문 종료
			} // switch문 종료
	} // 외부 for문 종료
} // 사용자정의함수 종료

// 1) 버블정렬의 로직: 마지막 원소자리부터 확정해나가며 점점 앞의 원소자리를 확정 (flag를 쓰지 않는 경우 선택정렬과 마찬가지로 N개 자료의 경우 N-1회전을 수행)
// 원소의 개수가 5개이고 오름차순정렬을 하는 경우에서 루프의 변화추이 관찰
// 루프#1: i=0(1회전): (0,1)->(1,2)->(2,3)->(3,4)->(4,5) // 목적: 5번째 원소(가장 큰 원소)를 확정
// 루프#2: i=1(2회전): (0,1)->(1,2)->(2,3)->(3,4) // 목적: 4번째 원소(두번째 큰 원소)를 확정
// 루프#3: i=2(3회전): (0,1)->(1,2)->(2,3) // 목적: 3번째 원소(세번째 큰 원소)를 확정
// 루프#4: i=3(4회전): (0,1)->(1,2) // 목적: 2번째 원소(네번째 큰 원소)를 확정 => 자동으로 가장 작은 원소가 확정
// 루프를 원소개수보다 하나 적게도는 이유: 마지막 원소는 마지막 루프를 돌 때 자동으로 결정되기 때문
// (단, 각 숫자는 각 자리의 원소를 의미 => 예: 1의 경우 첫번째 원소 저장값)
//
// 2) 버블정렬의 핵심문장설명 (오름차순 기준) // i는 회전수를 표시, j는 비교기준과 비교대상을 표시, N은 원소의 개수를 표시(마지막원소가 몇 번째인지 표시) 
// for(i=0; i<N-1; i++) // 외부 for문: 몇 번째 회전을 수행했는지 표현
// {
//     for(j=0; j<N-i-1; j++) // 내부 for문: j는 비교기준, j+1은 비교대상을 표시 
//     if(num[j] > num[j+1]) // 조건문: j번째 저장된 원소값이 j+1에 저장된 원소값보다 크면 j번째 원소저장값을 j+1번째 원소저장값과 Swap 
//     {
//         tmp = num[j]; // j번째 저장값을 임시저장변수인 tmp에 저장
//         num[j] = num[j+1]; // j+1번째 저장값을 j번째 원소위치에 저장 (num[j]의 기존값은 소멸)
//         num[j+1] = tmp; // j+1번째 원소위치에 j번째 저장값을 저장 (num[j+1]이 기존값은 소멸) 
// }
//
// 중요) selection은 앞에 것 제거 (앞에 것부터 확정), bubble은 뒤에 것 제거 (뒤에 것부터 확정)
// 참고) flag를 이용하지 않는 버블정렬의 외부 for문은 선택정렬의 외부 for문과 동일하다 => for(i=0; i<N-1; i++)
// 차이1: 내부 for문 => 선택정렬: "for(j=i; j<N ;j++)"  vs  버블정렬: "for(j=1; j<=N-i; j++)"
// 차이2: Swap문 => 선택정렬: "num[i]>num[j]"  vs   버블정렬: "num[j]>num[j+1]"

// (+) 선택정렬과 버블정렬이 자료에 따라 각각 몇 번의 루프를 돌고 종료하는 지 나타내보는 프로그램 작성해볼 것