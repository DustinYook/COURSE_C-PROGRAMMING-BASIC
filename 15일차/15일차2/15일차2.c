// 프로그램 목적: 두 배열의 원소를 바꿔넣는 프로그램
#include <stdio.h>

void Array_Swap(int* ptr1, int* ptr2, int N); // 함수선언 1: 주의) 배열위치 맞바꿀 때 두 배열의 크기는 동일해야 함
void Print(int input1, int input2, int* ptr, int N); // 함수선언 2

int main(void) // main함수 시작
{
	// 변수선언
	int a[5] = { 1,2,3,4,5 }; // Swap을 수행할 배열1 
	int b[5] = { 5,4,3,2,1 }; // Swap을 수행할 배열2
	int i = 0; // 제어변수: for문 제어
	int N = sizeof(a) / sizeof(int); // 배열의 크기를 저장 => 배열크기 같기 때문에 'a'또는'b' 중 아무거나 넣어도 동일

	// 함수호출 1: Swap 전 배열 저장값 출력
	Print(0, 2, a, N);
	Print(0, 3, b, N);
	printf("\n");

	// 함수호출 2: Swap 수행
	Array_Swap(a, b, N); // 함수호출: 배열의 시작주소들과 배열의 크기를 사용자정의함수에 전달 후 값을 반환받음

	// 함수호출 3: Swap 후 배열 저장값 출력
	Print(1, 2, a, N);
	Print(1, 3, b, N);
	printf("\n");

	return 0; // 실행종료
} // main함수 종료

void Print(int input1, int input2, int* ptr, int N) // 함수정의 1: 배열의 원소 출력
{
	// 변수선언
	int i = 0; // 제어변수
	char* string[4] = { "전", "후", "a", "b" }; // 출력변수: 출력문자 관리
	
	// 자료처리
	printf("교환 %s 배열 %s의 원소: ", string[input1] , string[input2]);
	for (i = 0; i < N; i++) // 모든 배열 원소 출력하도록 반복
		printf("%4d", *ptr++);
	printf("\n");
}

void Array_Swap(int* ptr1, int* ptr2, int N) // 함수정의 2: 두 배열의 원소 Swap
{
	int i = 0;
	int tmp = 0;

	for (i = 0; i < N; i++)
	{
		tmp = *(ptr1+i); // (1번 참고) (2번 참고)
		*(ptr1 + i) = *(ptr2 + i);
		*(ptr2 + i) = tmp;
	}
}

// 1) Swap 알고리즘
// Swap을 하기 위해서는 반드시 3개 변수가 필요하다 => 그 이유는 바로 아래 설명
// 변수 2개로 swap을 수행하는 예를 들어보자 => int a = 0, b = 1;
// a = b; // 1단계: a에는 원래 '0'이 저장되어 있었는데 대입연산을 하면서 b의 값 '1'로 갱신되고 이에 따라 기존 저장값 '0'은 소멸된다.
// b = a; // 2단계: b에 1단계에서 처리된 a의 값 '1'을 저장하게 되므로 b는 기존저장값과 동일한 '1'을 저장하게된다.
// 결론적으로 a와 b 모두 '1'이 저장되게 되어 논리적 오류가 발생하게 된다.
// 이를 방지하기 위해서 3개의 변수를 아래와 같이 사용할 수 있다.
// int a = 0, b = 1, tmp = 0;
// tmp = a; // 1단계: tmp라는 임시저장변수에 a의 값 '0'을 저장한다.
// a = b; // 2단계: a의 변수공간에 b의 값 '1'을 저장한다. (a의 기존저장값 '0'은 소실됨)
// b = tmp; // 3단계: b의 변수공간에 tmp에 저장된 기존 a의 값 '0'을 저장한다. (b의 기존저장값 '1'은 소실됨)
// 결론적으로 a는 기존 b의 저장값 '1'을 저장하게되고 b는 기존 a의 저장값 '0'을 저장하게 되어 a와 b의 저장값이 서로 바뀌어서 저장된 결과를 확일할 수 있다.
//
// 2) *(ptr1+i)대신 *ptr1++로 하면 논리적 오류가 발생하는 이유
// 1번) *(ptr1+i)를 이용하는 경우 (가정: i의 값은 '0')
// 1-1번 처리: tmp = *(ptr1+i); => "ptr1"의 주소에 저장된 값(ptr1[0])이 tmp변수에 저장
// 1-2번 처리: *(ptr1+i) = *(ptr2+i); => "ptr2"의 주소에 저장된 값(ptr2[0])이 "ptr1"의 주소를 가진 변수에 저장
// 1-3번 처리: *(ptr2+i) = tmp; => tmp에 저장된 값(ptr1[0])이 "ptr2"의 주소를 가진 변수에 저장
// 2번) *ptr1++를 이용하는 경우
// 2-1번 처리: tmp = *ptr1++; => "ptr1"의 주소에 저장된 값(ptr1[0])이 tmp변수에 저장
// 2-2번 처리: *ptr1++ = *ptr2++; => "ptr2"의 주소에 저장된 값(ptr2[0])이 "ptr1+1"의 주소를 가진 변수에 저장
// 2-3번 처리: *ptr2++ = tmp; => tmp에 저장된 값(ptr1[0])이 "ptr2+1"의 주소를 가진 변수에 저장
// 즉, 1번 대신 2번을 이용하게되면 한 원소씩 밀려서 값을 갱신하게 되는 논리적 오류가 발생하게 된다.